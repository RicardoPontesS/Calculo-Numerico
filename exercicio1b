import sympy as sp
import numpy as np
def retornoFuncao(x):
    expoente = 3
    resultado = 2 * (pow(x, expoente)) - 6 * x - 1
    return resultado
def verificaContinuidade(funcao, intervalo):
    x = sp.symbols('x')

    pontos = np.linspace(float(intervalo[0]), float(intervalo[1]), 100)

    for ponto in pontos:
        # Verifica se a função é contínua no ponto
        limite_esquerda = sp.limit(funcao, x, ponto, dir='-')
        limite_direita = sp.limit(funcao, x, ponto, dir='+')
        valor_ponto = funcao.subs(x, ponto)

        if limite_esquerda != limite_direita != valor_ponto:
            print(f"A função não é contínua em x = {ponto}")
            return False

    return True


def verificaDerivadaContinua(funcao, intervalo):
    x = sp.symbols('x')

    # Calcula a derivada da função
    derivada = sp.diff(funcao, x)

    for ponto in np.linspace(float(intervalo[0]), float(intervalo[1]), 100):
        # Verifica se a derivada é contínua no ponto
        limite_esquerda = sp.limit(derivada, x, ponto, dir='-')
        limite_direita = sp.limit(derivada, x, ponto, dir='+')
        valor_ponto = derivada.subs(x, ponto)

        if limite_esquerda != limite_direita != valor_ponto:
            print(f"A derivada não é contínua em x = {ponto}")
            return False

    return True


def verificaDerivadaMenorQueUm(derivada, intervalo):
    x = sp.symbols('x')

    for ponto in np.linspace(float(intervalo[0]), float(intervalo[1]), 100):
        valor_ponto = derivada.subs(x, ponto)

        if valor_ponto >= 1:
            print(f"Derivada é maior ou igual a 1 em x = {ponto}")
            return False
    return True

def verificaFuncoes():
    x = sp.symbols('x')
    intervalo = verificaIntervalo()  # Defina esta função de acordo com suas necessidades
    funcoes = modificaFuncao()  # Defina esta função de acordo com suas necessidades

    funcao_continua = None  # Variável para armazenar a função contínua

    for eq in funcoes:
        print(f"Função: {eq}")
        if verificaContinuidade(eq, intervalo):
            print("\nA primeira função contínua foi encontrada.")
            funcao_continua = eq
            break

    if funcao_continua:
        print(f"A função contínua é: {funcao_continua}")
        if verificaDerivadaContinua(funcao_continua, intervalo):
            print("A derivada também é contínua.")
            derivada = sp.diff(funcao_continua, x)
            if verificaDerivadaMenorQueUm(derivada, intervalo):
                print("A derivada é menor que 1 em todo o intervalo.")
                print(f"A função {funcao_continua} está apta para receber as iterações")
                return funcao_continua
            else:
                print("A derivada não é menor que 1 em todo o intervalo.")
        else:
            print("A derivada não é contínua.")
    else:
        print("\nNenhuma função contínua encontrada.")


def iteracoes():
    x = sp.symbols('x')
    epsilon = 0.0000001
    intervalo = verificaIntervalo()
    x0 = (intervalo[0] + intervalo[1]) / 2

    funcao = verificaFuncoes()

    xk = funcao.subs(x, x0)
    xk_anterior = x0  # Adicione esta linha para armazenar o valor anterior de xk

    while abs(xk - xk_anterior) > epsilon:
        xk_anterior = xk  # Atualize o valor anterior
        xk = funcao.subs(x, xk_anterior)

    # No final do loop, xk contém a aproximação do ponto fixo com a precisão especificada
    print(f"A raiz da função é: {xk}")



def verificaIntervalo():
    retorno1 = 0
    retorno2 = 0
    comecoIntervalo = 0
    fimIntervalo = 0
    i = 1
    comecoIntervalo = retornoFuncao(i)
    fimIntervalo = retornoFuncao(i + 1)
    while not ((retorno1 > 0 and retorno2 < 0) or (retorno1 < 0 and retorno2 > 0)):
        retorno1 = retornoFuncao(i)
        retorno2 = retornoFuncao(i + 1)
        comecoIntervalo = i
        fimIntervalo = i + 1
        i = i + 1
        if i > 15:
            i = -15
    intervalo = [comecoIntervalo, fimIntervalo]
    return intervalo

def calculaEExibeDerivada(equacao, x):
    derivada = sp.diff(equacao, x)
    return derivada

def modificaFuncao():
    # Define a variável simbólica x
    x = sp.symbols('x')

    # Define a lista de equações onde x está isolado
    equacoes_com_x_isolado = []

    # x = sqrt((6x+1)/2)
    equacao2 = ((6 * x + 1) / 2)**(1/3)
    equacoes_com_x_isolado.append(equacao2)

    # x^3 = (6x+1)/2
    equacao3 = x ** 3 - (6 * x + 1) / 2
    equacoes_com_x_isolado.append(equacao3)

    # x = (2x^3 - 1)/6
    equacao4 = (2 * x ** 3 - 1) / 6
    equacoes_com_x_isolado.append(equacao4)

    # 6x + 1 = 2x^3
    equacao5 = 6 * x + 1 - 2 * x ** 3
    equacoes_com_x_isolado.append(equacao5)

    # (6x+1)/2 = x^3
    equacao6 = (6 * x + 1) / 2 - x ** 3
    equacoes_com_x_isolado.append(equacao6)

    # 2x^3 - 6x = 1
    equacao7 = 2 * x ** 3 - 6 * x - 1
    equacoes_com_x_isolado.append(equacao7)

    # x = (1/2)(2x^3 - 1)
    equacao8 = (1 / 2) * (2 * x ** 3 - 1) - x
    equacoes_com_x_isolado.append(equacao8)
    # Exibe as equações onde x está isolado e suas derivadas
    for eq in equacoes_com_x_isolado:
        derivada = calculaEExibeDerivada(eq, x)
    return equacoes_com_x_isolado

if __name__ == '__main__':
    verificaFuncoes()
    iteracoes()
